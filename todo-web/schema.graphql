schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
type Query {
  allTasks(where: TaskItemFilterInput, order: [TaskItemSortInput!]): [TaskItem!]!
}
type Mutation {
  createTask(input: CreateTaskInput!): TaskPayload!
  updateTaskStatus(id: ID!, status: Status!): TaskPayload!
}
type Subscription {
  taskCreated: TaskItem!
  taskUpdated: TaskItem!
}
type TaskPayload {
  task: TaskItem!
}
type TaskItem {
  id: ID!
  title: String!
  description: String!
  status: Status!
}
enum SortEnumType {
  ASC
  DESC
}
enum Status {
  PENDING
  COMPLETED
}
input TaskItemFilterInput {
  and: [TaskItemFilterInput!]
  or: [TaskItemFilterInput!]
  id: IdOperationFilterInput
  title: StringOperationFilterInput
  description: StringOperationFilterInput
  status: StatusOperationFilterInput
}
input TaskItemSortInput {
  id: SortEnumType
  title: SortEnumType
  description: SortEnumType
  status: SortEnumType
}
input IdOperationFilterInput {
  eq: ID
  neq: ID
  in: [ID]
  nin: [ID]
}
input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}
input StatusOperationFilterInput {
  eq: Status
  neq: Status
  in: [Status!]
  nin: [Status!]
}
input CreateTaskInput {
  title: String!
  description: String
}
"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
    "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
    weight: String!
  ) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION
